/* ESTURURA DE CURSOR COM COMENTÁRIOS E EXPLICAÇÕES */

/* -- (PASSO A) - DECLARAÇÃO DE VARIÁVEIS - AS VARIÁVEIS SERÃO CRIADAS DE ACORDO COM OS CAMPOS DA SELECT NO CURSOR ABAIXO (PASSO B)*/
DECLARE	@CODCOLIGADA DCODCOLIGADA,
		@NOMEFANTASIA VARCHAR(255),
		@CGC VARCHAR(20)

/* -- (PASSO B) - DECLARAÇÃO DE CURSOR COM OS DADOS QUE PRECISARÃO ENTRARÃO NO CURSOR/LOOPING */
DECLARE CR_COLIGADA CURSOR FOR
	SELECT CODCOLIGADA, NOMEFANTASIA, CGC
	FROM DBO.GCOLIGADA
	ORDER BY CODCOLIGADA

/* -- (PASSO C) - APÓS CRIAR O CURSOR NO "PASSO B", É NECESSÁRIO INFORMAR AO SQL QUE ESTE CURSOR SERÁ UTILIZADO/ABERTO */
OPEN CR_COLIGADA

/* -- (PASSO D) - O COMANDO FETCH NESTA POSIÇÃO, ALIMENTARÁ AS VARIÁVEIS @CODCOLIGADA, @NOMEFANTASIA E @CGC COM O PRIMEIRO REGISTRO DO CURSOR - OU SEJA COM OS DADOS DA COLIGADA 0 */
FETCH NEXT FROM CR_COLIGADA INTO @CODCOLIGADA, @NOMEFANTASIA, @CGC

/* -- (PASSO E) - AQUI INICIA-SE O LOOPING/CURSOR*/
/* O CONTROLE DE QUANDO O CURSOR DEVE SE MANTER EM PROCESSAMENTO (LOPPING) OU DEVE SAIR DO LOOPING É FEITO ATRAVÉS DO COMANDO @@FETCH_STATUS = 0*/
/* OU SEJA.. ENQUANTO O FETCH_STATUS FOR IGUAL A 0 (ZERO) OU SEJA, AINDA TEM REGISTRO PARA SER TRATADO DENTRO DO CURSO, ELE MANTÉM-SE FUNCIONANDO */
/* QUANDO NÃO EXISTIR MAIS REGISTRO NO CURSOR O @@FWTCH_STATUS FICARÁ COMO -1 E ASSIM ELE SAIRÁ DO LOOPING/CURSOR*/
WHILE @@FETCH_STATUS = 0
BEGIN
	PRINT '-----------'
	PRINT 'COLIGADA: '+CONVERT(VARCHAR,@CODCOLIGADA)
	PRINT 'NOMEFANTASIA: '+CONVERT(VARCHAR,@NOMEFANTASIA)
	PRINT 'CGC: '+CONVERT(VARCHAR,@CGC)
	PRINT '-----------'

	/* -- (PASSO F) - ASSIM COMO  NO PASSO D, NESTE MOMENTO ELE ALIMENTARÁ AS VARIÁVEIS @CODCOLIGADA, @NOMEFANTASIA E @CGC COM OS DADOS DA PRÓXIMA COLIGADA...*/
	/*E REPETIRÁ ESTE PASSO ATÉ NÃO EXISTIR MAIS REGISTROS.. E QUANDO NÃO EXISIR MAIS REGISTROS ELE AVISARÁ O FETCH_STATUS (NO PASSO E) QUE É O MOMENTO DE FINALIZAR O LOOPING/CURSOR*/
	FETCH NEXT FROM CR_COLIGADA INTO @CODCOLIGADA, @NOMEFANTASIA, @CGC
END
/* -- (PASSO G) - FINALIZADO TODO O LOOPING/CURSOR, DEVEMOS INFORMAR O SQL SERVER QUE O CURSOR DEVE SER FECHADO (OU SEJA RETIRADO DA MEMÓRIA RAM)*/
CLOSE CR_COLIGADA
/* -- (PASSO H) - ESTE PONTO NEM É NECESSÁRIO, MAS EM ALGUMAS VERSÕES DO SQL SERVER SOMENTE O CLOSE (PASSO G), NÃO RETIRAVA O CURSOR DA MEMÓRIA. ENTÃO COM O COMANDO ABAIXO*/
/* EU ME CERTIFICO QUE NÃO EXISTE MAIS NENHUM REGISTRO CONSUMINDO A MEMÓRIA RAM*/
DEALLOCATE CR_COLIGADA






PRINT @CODCOLIGADA



